<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Game</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000000;
            background-image: 
                radial-gradient(circle at 25% 25%, #0d4f3c 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, #1a3d2e 0%, transparent 50%),
                linear-gradient(45deg, #000000 0%, #0f2027 50%, #203a43 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00ff41;
            overflow-x: auto;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 
                0 0 40px rgba(0, 255, 65, 0.4),
                inset 0 0 30px rgba(0, 255, 65, 0.1);
            max-width: 1200px;
            width: 100%;
            position: relative;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff41, #ff0040, #00ff41);
            border-radius: 15px;
            z-index: -1;
            animation: border-pulse 3s ease-in-out infinite alternate;
        }

        @keyframes border-pulse {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-title {
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 10px;
            color: #00ff41;
            text-shadow: 
                0 0 10px #00ff41,
                0 0 20px #00ff41,
                0 0 30px #00ff41;
            letter-spacing: 3px;
            animation: title-glow 2s ease-in-out infinite alternate;
        }

        @keyframes title-glow {
            from { text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41, 0 0 30px #00ff41; }
            to { text-shadow: 0 0 15px #00ff41, 0 0 25px #00ff41, 0 0 35px #00ff41; }
        }

        .game-status {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            color: #00ff41;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.2);
        }

        .game-boards {
            display: flex;
            justify-content: space-around;
            gap: 40px;
            flex-wrap: wrap;
        }

        .player-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .player-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            font-weight: 700;
            color: #00ff41;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ff41;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 35px);
            grid-template-rows: repeat(10, 35px);
            gap: 1px;
            background: #000000;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #00ff41;
            box-shadow: 
                0 0 30px rgba(0, 255, 65, 0.4),
                inset 0 0 20px rgba(0, 255, 65, 0.1);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .game-board::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(90deg, transparent 49%, rgba(0, 255, 65, 0.1) 50%, transparent 51%),
                linear-gradient(0deg, transparent 49%, rgba(0, 255, 65, 0.1) 50%, transparent 51%);
            background-size: 10% 10%;
            pointer-events: none;
            z-index: 1;
        }

        .game-board::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 50%;
            background: linear-gradient(to bottom, #00ff41, transparent);
            transform-origin: bottom center;
            transform: translate(-50%, 0) rotate(0deg);
            animation: radar-sweep 4s linear infinite;
            z-index: 3;
            pointer-events: none;
        }

        @keyframes radar-sweep {
            0% { transform: translate(-50%, 0) rotate(0deg); opacity: 1; }
            100% { transform: translate(-50%, 0) rotate(360deg); opacity: 1; }
        }

        .cell {
            width: 35px;
            height: 35px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            z-index: 2;
        }

        .cell:hover {
            background: rgba(0, 255, 65, 0.2);
            border-color: #00ff41;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
            transform: scale(1.1);
        }

        .cell.ship {
            background: rgba(0, 255, 65, 0.4);
            border-color: #00ff41;
            box-shadow: 
                0 0 10px rgba(0, 255, 65, 0.6),
                inset 0 0 10px rgba(0, 255, 65, 0.2);
            font-size: 18px;
            position: relative;
        }

        .cell.ship::after {
            content: 'üö¢';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            filter: hue-rotate(120deg) brightness(1.2);
        }

        /* Different ship types for variety */
        .cell.ship.carrier::after {
            content: 'üõ≥Ô∏è';
            font-size: 14px;
        }

        .cell.ship.battleship::after {
            content: '‚öì';
            font-size: 14px;
        }

        .cell.ship.cruiser::after {
            content: 'üö§';
            font-size: 14px;
        }

        .cell.ship.submarine::after {
            content: 'ü§ø';
            font-size: 12px;
        }

        .cell.ship.destroyer::after {
            content: '‚õµ';
            font-size: 14px;
        }

        .cell.hit {
            background: rgba(255, 0, 64, 0.8);
            border-color: #ff0040;
            box-shadow: 
                0 0 20px rgba(255, 0, 64, 0.8),
                inset 0 0 10px rgba(255, 0, 64, 0.3);
            animation: hit-explosion 0.6s ease-out;
        }

        .cell.hit::after {
            content: 'üí•';
            font-size: 18px;
            animation: hit-spin 0.6s ease-out;
            z-index: 10;
        }

        .cell.hit.ship::after {
            content: 'üî•';
            font-size: 16px;
        }

        .cell.miss {
            background: rgba(100, 100, 100, 0.6);
            border-color: #666666;
        }

        .cell.miss::after {
            content: '‚óã';
            color: #cccccc;
            font-size: 16px;
            font-weight: bold;
        }

        @keyframes hit-explosion {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
            }
            50% {
                transform: scale(1.3);
                box-shadow: 0 0 40px rgba(255, 0, 64, 1);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
            }
        }

        @keyframes hit-spin {
            0% { transform: rotate(0deg) scale(0.5); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .ship-placement {
            margin-bottom: 20px;
            text-align: center;
        }

        .ship-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .ship-item {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #00ff41;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ship-item:hover {
            background: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.4);
            transform: scale(1.05);
        }

        .ship-item.selected {
            background: rgba(0, 255, 65, 0.2);
            border-color: #00ff41;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        .ship-item.placed {
            background: rgba(0, 0, 0, 0.5);
            border-color: #004d1a;
            color: #004d1a;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            color: #00ff41;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            background: rgba(0, 255, 65, 0.1);
            box-shadow: 
                0 0 20px rgba(0, 255, 65, 0.4),
                inset 0 0 20px rgba(0, 255, 65, 0.1);
            transform: translateY(-2px);
        }

        .btn-primary {
            border-color: #00ff41;
            color: #00ff41;
        }

        .btn-success {
            border-color: #00ff41;
            color: #00ff41;
        }

        .btn-warning {
            border-color: #ffff00;
            color: #ffff00;
        }

        .btn-warning:hover {
            background: rgba(255, 255, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.4);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .phase-setup {
            text-align: center;
        }

        .game-container.setup-phase .player-section:not(.current-player) {
            display: none;
        }

        .phase-game .player-section:not(.active) {
            opacity: 0.6;
            pointer-events: none;
        }

        .phase-game .player-section.active {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-modal {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 65, 0.5);
        }

        .game-over-title {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #00ff41;
            text-shadow: 0 0 20px #00ff41;
        }

        .game-over-message {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: #00ff41;
        }

        .connection-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            background-image: 
                radial-gradient(circle at 25% 25%, #0d4f3c 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, #1a3d2e 0%, transparent 50%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .connection-modal {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 0 40px rgba(0, 255, 65, 0.4);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .connection-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #00ff41;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            text-shadow: 0 0 15px #00ff41;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .connection-options {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .room-input {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1.2rem;
            font-family: 'Share Tech Mono', monospace;
            text-align: center;
            color: #00ff41;
            margin: 10px;
            min-width: 200px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .room-input::placeholder {
            color: rgba(0, 255, 65, 0.5);
        }

        .room-input:focus {
            outline: none;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
        }

        .room-code {
            font-size: 2.5rem;
            font-weight: 900;
            color: #00ff41;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            padding: 15px 25px;
            border-radius: 12px;
            margin: 20px 0;
            letter-spacing: 6px;
            font-family: 'Share Tech Mono', monospace;
            text-shadow: 0 0 15px #00ff41;
            animation: code-pulse 2s ease-in-out infinite alternate;
        }

        @keyframes code-pulse {
            from { text-shadow: 0 0 15px #00ff41; }
            to { text-shadow: 0 0 25px #00ff41, 0 0 35px #00ff41; }
        }

        .waiting-message {
            font-size: 1.2rem;
            color: #00ff41;
            margin: 20px 0;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-status {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ff41;
            border-radius: 10px;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-info.connected {
            color: #00ff41;
        }

        .player-info.disconnected {
            color: #ff0040;
        }

        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-top: 5px;
        }

        .connected .connection-indicator {
            background: #00ff41;
            box-shadow: 0 0 10px #00ff41;
            animation: indicator-pulse 2s ease-in-out infinite;
        }

        .disconnected .connection-indicator {
            background: #ff0040;
            box-shadow: 0 0 10px #ff0040;
        }

        @keyframes indicator-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 768px) {
            .game-boards {
                flex-direction: column;
                align-items: center;
            }
            
            .game-title {
                font-size: 2rem;
            }
            
            .game-board {
                grid-template-columns: repeat(10, 30px);
                grid-template-rows: repeat(10, 30px);
            }
            
            .cell {
                width: 30px;
                height: 30px;
            }

            .connection-title {
                font-size: 2rem;
            }

            .room-code {
                font-size: 2rem;
                letter-spacing: 4px;
            }
        }
    </style>
</head>
<body>
    <!-- Connection Screen -->
    <div class="connection-screen" id="connectionScreen">
        <div class="connection-modal">
            <div class="connection-title">üö¢ Join Battle</div>
            
            <div id="connectionMenu">
                <div class="connection-options">
                    <button class="btn btn-primary" id="createRoomBtn">üéØ Create Room</button>
                    <button class="btn btn-success" id="joinRoomBtn">üîó Join Room</button>
                </div>
            </div>
            
            <div id="joinRoomSection" style="display: none;">
                <h3 style="color: white; margin-bottom: 20px;">Enter Room Code</h3>
                <input type="text" class="room-input" id="roomCodeInput" placeholder="Enter Room Code" maxlength="6" style="display: block; margin: 0 auto 20px auto;">
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-success" id="joinGameBtn">Join Game</button>
                    <button class="btn btn-primary" id="backBtn">Back</button>
                </div>
            </div>
            
            <div id="roomWaiting" style="display: none;">
                <div class="room-code" id="displayRoomCode"></div>
                <div class="waiting-message">Waiting for opponent to join...</div>
                <div class="waiting-message">Share this code with your friend!</div>
                <button class="btn btn-primary" id="cancelRoomBtn">Cancel</button>
            </div>
            
            <div id="gameReady" style="display: none;">
                <div class="waiting-message">Both players connected!</div>
                <div class="player-status">
                    <div class="player-info connected" id="player1Info">
                        <span>You</span>
                        <div class="connection-indicator"></div>
                    </div>
                    <div class="player-info connected" id="player2Info">
                        <span>Opponent</span>
                        <div class="connection-indicator"></div>
                    </div>
                </div>
                <button class="btn btn-success" id="startMultiplayerBtn">Start Game!</button>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">‚öì BATTLESHIP ‚öì</h1>
            <div class="game-status" id="gameStatus">Player 1: Place your ships</div>
        </div>

        <div class="phase-setup" id="setupPhase">
            <div class="ship-placement">
                <h3>Available Ships:</h3>
                <div class="ship-list" id="shipList">
                    <div class="ship-item" data-ship="carrier" data-size="5">üõ≥Ô∏è Carrier (5)</div>
                    <div class="ship-item" data-ship="battleship" data-size="4">‚öì Battleship (4)</div>
                    <div class="ship-item" data-ship="cruiser" data-size="3">üö§ Cruiser (3)</div>
                    <div class="ship-item" data-ship="submarine" data-size="3">ü§ø Submarine (3)</div>
                    <div class="ship-item" data-ship="destroyer" data-size="2">‚õµ Destroyer (2)</div>
                </div>
                <div class="controls">
                    <button class="btn btn-warning" id="rotateBtn">üîÑ Rotate Ship</button>
                    <button class="btn btn-primary" id="randomBtn">üé≤ Random Placement</button>
                    <button class="btn btn-success" id="readyBtn" disabled>‚úÖ Ready to Battle</button>
                </div>
            </div>
        </div>

        <div class="game-boards">
            <div class="player-section" id="player1Section">
                <h2 class="player-title">üéØ Your Fleet</h2>
                <div class="game-board" id="player1Board"></div>
            </div>
            <div class="player-section" id="player2Section">
                <h2 class="player-title">üéØ Enemy Fleet</h2>
                <div class="game-board" id="player2Board"></div>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBO87pxL-XpGERh_GBSS_Xd8lQKeEKqZ9A",
            authDomain: "battleship-807ff.firebaseapp.com",
            databaseURL: "https://battleship-807ff-default-rtdb.firebaseio.com",
            projectId: "battleship-807ff",
            storageBucket: "battleship-807ff.firebasestorage.app",
            messagingSenderId: "407386930564",
            appId: "1:407386930564:web:cfd10fcaf2e20fba57f1d1",
            measurementId: "G-3HN995NF5T"
          };

        class BattleshipGame {
            constructor() {
                this.isMultiplayer = true;
                this.roomCode = null;
                this.playerId = null;
                this.playerNumber = null;
                this.opponentConnected = false;
                this.gamePhase = 'connection'; // 'connection', 'setup', 'game', 'over'
                this.selectedShip = null;
                this.shipOrientation = 'horizontal';
                
                this.ships = {
                    carrier: { size: 5, placed: false },
                    battleship: { size: 4, placed: false },
                    cruiser: { size: 3, placed: false },
                    submarine: { size: 3, placed: false },
                    destroyer: { size: 2, placed: false }
                };

                this.gameState = {
                    players: {
                        1: {
                            board: this.createEmptyBoard(),
                            ships: JSON.parse(JSON.stringify(this.ships)),
                            shipsReady: false,
                            connected: false
                        },
                        2: {
                            board: this.createEmptyBoard(),
                            ships: JSON.parse(JSON.stringify(this.ships)),
                            shipsReady: false,
                            connected: false
                        }
                    },
                    currentPlayer: 1,
                    gameStarted: false,
                    gameOver: false,
                    winner: null
                };

                this.initializeFirebase();
                this.initializeDOM();
                this.bindEvents();
                this.showConnectionScreen();
            }

            updateGamePhaseClasses() {
                const gameContainer = document.querySelector('.game-container');
                // Remove all phase classes
                gameContainer.classList.remove('setup-phase', 'game-phase', 'connection-phase');
                
                // Add current phase class
                if (this.gamePhase === 'setup') {
                    gameContainer.classList.add('setup-phase');
                } else if (this.gamePhase === 'game') {
                    gameContainer.classList.add('game-phase');
                } else if (this.gamePhase === 'connection') {
                    gameContainer.classList.add('connection-phase');
                }
            }

            createEmptyBoard() {
                return Array(10).fill().map(() => Array(10).fill(0));
            }

            initializeFirebase() {
                try {
                    if (!firebase.apps.length) {
                        firebase.initializeApp(firebaseConfig);
                    }
                    this.database = firebase.database();
                    this.playerId = this.generatePlayerId();
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    alert('Connection failed. Please check your internet connection.');
                }
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            generateRoomCode() {
                return Math.random().toString(36).substr(2, 6).toUpperCase();
            }

            initializeDOM() {
                // Connection screen elements
                this.connectionScreen = document.getElementById('connectionScreen');
                this.createRoomBtn = document.getElementById('createRoomBtn');
                this.joinRoomBtn = document.getElementById('joinRoomBtn');
                this.joinRoomSection = document.getElementById('joinRoomSection');
                this.roomCodeInput = document.getElementById('roomCodeInput');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.backBtn = document.getElementById('backBtn');
                this.roomWaiting = document.getElementById('roomWaiting');
                this.displayRoomCode = document.getElementById('displayRoomCode');
                this.cancelRoomBtn = document.getElementById('cancelRoomBtn');
                this.gameReady = document.getElementById('gameReady');
                this.startMultiplayerBtn = document.getElementById('startMultiplayerBtn');
                this.connectionMenu = document.getElementById('connectionMenu');

                // Game elements
                this.gameStatus = document.getElementById('gameStatus');
                this.setupPhase = document.getElementById('setupPhase');
                this.shipList = document.getElementById('shipList');
                this.rotateBtn = document.getElementById('rotateBtn');
                this.randomBtn = document.getElementById('randomBtn');
                this.readyBtn = document.getElementById('readyBtn');
                this.player1Board = document.getElementById('player1Board');
                this.player2Board = document.getElementById('player2Board');
                this.player1Section = document.getElementById('player1Section');
                this.player2Section = document.getElementById('player2Section');
            }

            bindEvents() {
                // Connection events
                this.createRoomBtn.addEventListener('click', () => this.createRoom());
                this.joinRoomBtn.addEventListener('click', () => this.showJoinRoom());
                this.joinGameBtn.addEventListener('click', () => this.joinRoom());
                this.backBtn.addEventListener('click', () => this.showConnectionMenu());
                this.cancelRoomBtn.addEventListener('click', () => this.cancelRoom());
                this.startMultiplayerBtn.addEventListener('click', () => this.startMultiplayerGame());

                // Game events
                this.shipList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('ship-item') && !e.target.classList.contains('placed')) {
                        this.selectShip(e.target);
                    }
                });

                this.rotateBtn.addEventListener('click', () => {
                    this.shipOrientation = this.shipOrientation === 'horizontal' ? 'vertical' : 'horizontal';
                    this.rotateBtn.textContent = `üîÑ Rotate Ship (${this.shipOrientation})`;
                });

                this.randomBtn.addEventListener('click', () => {
                    this.randomPlacement();
                });

                this.readyBtn.addEventListener('click', () => {
                    this.confirmShipPlacement();
                });

                // Room code input enter key
                this.roomCodeInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.joinRoom();
                    }
                });
            }

            // Connection methods
            showConnectionScreen() {
                this.connectionScreen.style.display = 'flex';
            }

            hideConnectionScreen() {
                this.connectionScreen.style.display = 'none';
            }

            showConnectionMenu() {
                this.connectionMenu.style.display = 'block';
                this.joinRoomSection.style.display = 'none';
                this.roomWaiting.style.display = 'none';
                this.gameReady.style.display = 'none';
            }

            showJoinRoom() {
                this.connectionMenu.style.display = 'none';
                this.joinRoomSection.style.display = 'block';
                this.roomCodeInput.focus();
            }

            async createRoom() {
                try {
                    this.roomCode = this.generateRoomCode();
                    this.playerNumber = 1;
                    
                    const roomRef = this.database.ref(`rooms/${this.roomCode}`);
                    await roomRef.set({
                        host: this.playerId,
                        players: {
                            1: {
                                id: this.playerId,
                                connected: true,
                                board: this.createEmptyBoard(),
                                ships: this.ships,
                                shipsReady: false
                            }
                        },
                        gameState: {
                            currentPlayer: 1,
                            gameStarted: false,
                            gameOver: false,
                            winner: null
                        },
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    });

                    this.listenToRoom();
                    this.showWaitingRoom();
                } catch (error) {
                    console.error('Error creating room:', error);
                    alert('Failed to create room. Please try again.');
                }
            }

            async joinRoom() {
                const roomCode = this.roomCodeInput.value.trim().toUpperCase();
                if (roomCode.length !== 6) {
                    alert('Please enter a valid 6-character room code.');
                    return;
                }

                try {
                    const roomRef = this.database.ref(`rooms/${roomCode}`);
                    const snapshot = await roomRef.once('value');
                    
                    if (!snapshot.exists()) {
                        alert('Room not found. Please check the room code.');
                        return;
                    }

                    const roomData = snapshot.val();
                    if (roomData.players && Object.keys(roomData.players).length >= 2) {
                        alert('Room is full.');
                        return;
                    }

                    this.roomCode = roomCode;
                    this.playerNumber = 2;

                    // Join the room
                    await roomRef.child('players/2').set({
                        id: this.playerId,
                        connected: true,
                        board: this.createEmptyBoard(),
                        ships: this.ships,
                        shipsReady: false
                    });

                    this.listenToRoom();
                    this.showGameReady();
                } catch (error) {
                    console.error('Error joining room:', error);
                    alert('Failed to join room. Please try again.');
                }
            }

            showWaitingRoom() {
                this.connectionMenu.style.display = 'none';
                this.joinRoomSection.style.display = 'none';
                this.roomWaiting.style.display = 'block';
                this.displayRoomCode.textContent = this.roomCode;
            }

            showGameReady() {
                this.connectionMenu.style.display = 'none';
                this.joinRoomSection.style.display = 'none';
                this.roomWaiting.style.display = 'none';
                this.gameReady.style.display = 'block';
            }

            listenToRoom() {
                if (!this.roomCode) return;

                const roomRef = this.database.ref(`rooms/${this.roomCode}`);
                
                roomRef.on('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        this.handleRoomClosed();
                        return;
                    }

                    const roomData = snapshot.val();
                    this.handleRoomUpdate(roomData);
                });

                // Handle disconnection
                roomRef.child(`players/${this.playerNumber}/connected`).onDisconnect().set(false);
            }

            handleRoomUpdate(roomData) {
                if (!roomData || !roomData.players) return;

                // Check if both players are connected
                const players = roomData.players;
                const bothConnected = players[1] && players[2] && players[1].connected && players[2].connected;

                if (bothConnected && this.gamePhase === 'connection') {
                    if (this.playerNumber === 1) {
                        this.showGameReady();
                    }
                } else if (this.gamePhase === 'connection' && this.playerNumber === 1) {
                    this.showWaitingRoom();
                }

                // Update game state if game has started
                if (roomData.gameState && roomData.gameState.gameStarted && this.gamePhase !== 'game' && this.gamePhase !== 'over') {
                    this.gameState = roomData;
                    this.startGame();
                } else if (roomData.gameState && roomData.gameState.battlePhase && this.gamePhase === 'setup') {
                    this.gameState = roomData;
                    this.gamePhase = 'game';
                    this.updateGamePhaseClasses();
                    this.setupPhase.style.display = 'none';
                    this.renderBoards();
                    this.updatePlayerSections();
                    this.updateStatus();
                } else if (this.gamePhase === 'game' || this.gamePhase === 'setup') {
                    this.gameState = roomData;
                    this.syncGameState();
                }
            }

            async cancelRoom() {
                if (this.roomCode) {
                    try {
                        await this.database.ref(`rooms/${this.roomCode}`).remove();
                    } catch (error) {
                        console.error('Error canceling room:', error);
                    }
                }
                this.showConnectionMenu();
            }

            handleRoomClosed() {
                if (this.gamePhase !== 'over') {
                    alert('The room has been closed by the host.');
                    this.showConnectionMenu();
                }
            }

            async startMultiplayerGame() {
                if (this.playerNumber === 1) {
                    try {
                        await this.database.ref(`rooms/${this.roomCode}/gameState/gameStarted`).set(true);
                    } catch (error) {
                        console.error('Error starting game:', error);
                    }
                }
            }

            startGame() {
                this.gamePhase = 'setup';
                this.updateGamePhaseClasses();
                this.hideConnectionScreen();
                this.renderBoards();
                this.updatePlayerSections();
                this.updateStatus();
            }

            selectShip(shipElement) {
                // Remove selection from all ships
                document.querySelectorAll('.ship-item').forEach(item => {
                    item.classList.remove('selected');
                });

                // Select the clicked ship
                shipElement.classList.add('selected');
                this.selectedShip = {
                    type: shipElement.dataset.ship,
                    size: parseInt(shipElement.dataset.size)
                };
            }

            renderBoards() {
                this.renderBoard(this.player1Board, 1);
                this.renderBoard(this.player2Board, 2);
            }

            renderBoard(boardElement, player) {
                if (!this.gameState || !this.gameState.players) return;
                
                boardElement.innerHTML = '';
                const board = this.gameState.players[player].board;

                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.dataset.player = player;

                        const cellValue = board[row][col];
                        
                        if (this.gamePhase === 'setup' && player === this.playerNumber) {
                            if (cellValue === 1) {
                                cell.classList.add('ship');
                                // Add consistent ship type class based on position for visual variety
                                const shipTypeClasses = ['carrier', 'battleship', 'cruiser', 'submarine', 'destroyer'];
                                const typeIndex = (row + col) % shipTypeClasses.length;
                                cell.classList.add(shipTypeClasses[typeIndex]);
                            }
                            cell.addEventListener('click', (e) => this.handleCellClick(e));
                        } else if (this.gamePhase === 'game') {
                            if (player !== this.playerNumber) {
                                // Opponent's board - show hits and misses only
                                if (cellValue === 2) cell.classList.add('hit');
                                if (cellValue === -1) cell.classList.add('miss');
                                if ((cellValue === 0 || cellValue === 1) && this.gameState.gameState && this.gameState.gameState.currentPlayer === this.playerNumber && !this.gameState.gameState.gameOver) {
                                    cell.addEventListener('click', (e) => this.handleAttack(e));
                                }
                            } else {
                                // Own board - show ships, hits, and misses
                                if (cellValue === 1) {
                                    cell.classList.add('ship');
                                    // Add consistent ship type class based on position for visual variety
                                    const shipTypeClasses = ['carrier', 'battleship', 'cruiser', 'submarine', 'destroyer'];
                                    const typeIndex = (row + col) % shipTypeClasses.length;
                                    cell.classList.add(shipTypeClasses[typeIndex]);
                                }
                                if (cellValue === 2) {
                                    cell.classList.add('hit');
                                    cell.classList.add('ship'); // Keep ship class to show it was a ship hit
                                }
                                if (cellValue === -1) cell.classList.add('miss');
                            }
                        }

                        boardElement.appendChild(cell);
                    }
                }
            }

            syncGameState() {
                // Check if we should be in battle phase but aren't
                if (this.gameState && this.gameState.gameState && this.gameState.gameState.battlePhase && this.gamePhase !== 'game') {
                    this.gamePhase = 'game';
                    this.updateGamePhaseClasses();
                    this.setupPhase.style.display = 'none';
                }
                
                if (this.gamePhase === 'game') {
                    this.renderBoards();
                    this.updatePlayerSections();
                    this.checkGameEnd();
                }
                this.updateStatus();
            }

            async handleCellClick(e) {
                if (!this.selectedShip || this.gamePhase !== 'setup') return;

                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                const player = parseInt(e.target.dataset.player);

                if (player !== this.playerNumber) return;

                if (this.canPlaceShip(row, col, this.selectedShip.size, this.shipOrientation, player)) {
                    await this.placeShip(row, col, this.selectedShip.size, this.shipOrientation, player, this.selectedShip.type);
                    await this.markShipAsPlaced(this.selectedShip.type);
                    this.selectedShip = null;
                    this.checkReadyState();
                    this.renderBoards();
                }
            }

            canPlaceShip(row, col, size, orientation, player) {
                if (!this.gameState || !this.gameState.players) return false;
                const board = this.gameState.players[player].board;

                for (let i = 0; i < size; i++) {
                    const currentRow = orientation === 'horizontal' ? row : row + i;
                    const currentCol = orientation === 'horizontal' ? col + i : col;

                    // Check bounds
                    if (currentRow >= 10 || currentCol >= 10) return false;

                    // Check if cell is already occupied
                    if (board[currentRow][currentCol] !== 0) return false;

                    // Check adjacent cells for other ships
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const adjRow = currentRow + dr;
                            const adjCol = currentCol + dc;
                            if (adjRow >= 0 && adjRow < 10 && adjCol >= 0 && adjCol < 10) {
                                if (board[adjRow][adjCol] === 1) {
                                    // Check if this adjacent ship cell is part of the current placement
                                    let isPartOfCurrentShip = false;
                                    for (let j = 0; j < size; j++) {
                                        const shipRow = orientation === 'horizontal' ? row : row + j;
                                        const shipCol = orientation === 'horizontal' ? col + j : col;
                                        if (adjRow === shipRow && adjCol === shipCol) {
                                            isPartOfCurrentShip = true;
                                            break;
                                        }
                                    }
                                    if (!isPartOfCurrentShip) return false;
                                }
                            }
                        }
                    }
                }

                return true;
            }

            async placeShip(row, col, size, orientation, player, shipType = null) {
                if (!this.gameState || !this.gameState.players) return;
                
                const updates = {};
                for (let i = 0; i < size; i++) {
                    const currentRow = orientation === 'horizontal' ? row : row + i;
                    const currentCol = orientation === 'horizontal' ? col + i : col;
                    updates[`rooms/${this.roomCode}/players/${player}/board/${currentRow}/${currentCol}`] = 1;
                }

                try {
                    await this.database.ref().update(updates);
                } catch (error) {
                    console.error('Error placing ship:', error);
                }
            }

            async markShipAsPlaced(shipType) {
                try {
                    await this.database.ref(`rooms/${this.roomCode}/players/${this.playerNumber}/ships/${shipType}/placed`).set(true);
                    
                    const shipElement = document.querySelector(`[data-ship="${shipType}"]`);
                    shipElement.classList.add('placed');
                    shipElement.classList.remove('selected');
                } catch (error) {
                    console.error('Error marking ship as placed:', error);
                }
            }

            checkReadyState() {
                if (!this.gameState || !this.gameState.players) return;
                
                const allShipsPlaced = Object.values(this.gameState.players[this.playerNumber].ships).every(ship => ship.placed);
                this.readyBtn.disabled = !allShipsPlaced;
                
                if (allShipsPlaced) {
                    this.readyBtn.textContent = '‚úÖ Ready to Battle';
                } else {
                    this.readyBtn.textContent = `‚úÖ Ready to Battle (${Object.values(this.gameState.players[this.playerNumber].ships).filter(s => !s.placed).length} ships left)`;
                }
            }

            async confirmShipPlacement() {
                try {
                    await this.database.ref(`rooms/${this.roomCode}/players/${this.playerNumber}/shipsReady`).set(true);
                    
                    // Check if both players are ready
                    const snapshot = await this.database.ref(`rooms/${this.roomCode}/players`).once('value');
                    const players = snapshot.val();
                    
                    if (players && players[1] && players[2] && players[1].shipsReady && players[2].shipsReady) {
                        // Start the battle phase - only host (player 1) sets this
                        if (this.playerNumber === 1) {
                            await this.database.ref(`rooms/${this.roomCode}/gameState`).update({
                                currentPlayer: 1,
                                gameStarted: true,
                                battlePhase: true
                            });
                        }
                        
                        this.gamePhase = 'game';
                        this.updateGamePhaseClasses();
                        this.setupPhase.style.display = 'none';
                        this.renderBoards();
                        this.updatePlayerSections();
                        this.updateStatus();
                    } else {
                        this.gameStatus.textContent = 'Waiting for opponent to finish ship placement...';
                        this.setupPhase.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error confirming ship placement:', error);
                }
            }

            resetShipSelection() {
                document.querySelectorAll('.ship-item').forEach(item => {
                    item.classList.remove('placed', 'selected');
                });
                this.selectedShip = null;
                this.readyBtn.disabled = true;
                this.checkReadyState();
            }

            updatePlayerSections() {
                // Update titles based on player perspective
                const player1Title = this.player1Section.querySelector('.player-title');
                const player2Title = this.player2Section.querySelector('.player-title');
                
                if (this.playerNumber === 1) {
                    player1Title.textContent = 'üéØ Your Fleet';
                    player2Title.textContent = 'üéØ Enemy Fleet';
                } else {
                    player1Title.textContent = 'üéØ Enemy Fleet';
                    player2Title.textContent = 'üéØ Your Fleet';
                }

                if (this.gamePhase === 'setup') {
                    // During setup, only show current player's board
                    this.player1Section.classList.toggle('current-player', this.playerNumber === 1);
                    this.player2Section.classList.toggle('current-player', this.playerNumber === 2);
                } else if (this.gamePhase === 'game' && this.gameState && this.gameState.gameState) {
                    // Remove setup classes
                    this.player1Section.classList.remove('current-player');
                    this.player2Section.classList.remove('current-player');
                    
                    // Show both boards and highlight active player
                    const currentPlayer = this.gameState.gameState.currentPlayer;
                    this.player1Section.classList.toggle('active', currentPlayer === 1);
                    this.player2Section.classList.toggle('active', currentPlayer === 2);
                    
                    // Add class to show which section is for the current user
                    this.player1Section.classList.toggle('own-board', this.playerNumber === 1);
                    this.player2Section.classList.toggle('own-board', this.playerNumber === 2);
                }
            }

            async handleAttack(e) {
                if (this.gamePhase !== 'game' || !this.gameState || !this.gameState.gameState) return;
                if (this.gameState.gameState.currentPlayer !== this.playerNumber) return;
                if (this.gameState.gameState.gameOver) return;

                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                const targetPlayer = parseInt(e.target.dataset.player);

                if (targetPlayer === this.playerNumber) return; // Can't attack own board

                const board = this.gameState.players[targetPlayer].board;
                const cellValue = board[row][col];

                if (cellValue === 2 || cellValue === -1) return; // Already attacked

                try {
                    let nextPlayer = this.playerNumber;
                    
                    if (cellValue === 1) {
                        // Hit!
                        await this.database.ref(`rooms/${this.roomCode}/players/${targetPlayer}/board/${row}/${col}`).set(2);
                        
                        // Check win condition
                        const updatedSnapshot = await this.database.ref(`rooms/${this.roomCode}/players/${targetPlayer}/board`).once('value');
                        const updatedBoard = updatedSnapshot.val();
                        
                        if (this.checkWinConditionFromBoard(updatedBoard)) {
                            await this.database.ref(`rooms/${this.roomCode}/gameState`).update({
                                gameOver: true,
                                winner: this.playerNumber
                            });
                            return;
                        }
                        // Stay same player on hit
                    } else {
                        // Miss
                        await this.database.ref(`rooms/${this.roomCode}/players/${targetPlayer}/board/${row}/${col}`).set(-1);
                        nextPlayer = this.playerNumber === 1 ? 2 : 1;
                    }

                    // Update current player
                    await this.database.ref(`rooms/${this.roomCode}/gameState/currentPlayer`).set(nextPlayer);
                } catch (error) {
                    console.error('Error handling attack:', error);
                }
            }

            checkWinConditionFromBoard(board) {
                if (!board) return false;
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        if (board[row] && board[row][col] === 1) {
                            return false; // Still has unhit ship cells
                        }
                    }
                }
                return true;
            }

            checkGameEnd() {
                if (!this.gameState || !this.gameState.gameState) return;
                
                if (this.gameState.gameState.gameOver) {
                    this.endGame(this.gameState.gameState.winner);
                }
            }

            endGame(winner) {
                this.gamePhase = 'over';
                this.updateGamePhaseClasses();
                
                const gameOverModal = document.createElement('div');
                gameOverModal.className = 'game-over';
                const isWinner = winner === this.playerNumber;
                gameOverModal.innerHTML = `
                    <div class="game-over-modal">
                        <div class="game-over-title">${isWinner ? 'üéâ VICTORY! üéâ' : 'üíÄ DEFEAT üíÄ'}</div>
                        <div class="game-over-message">${isWinner ? 'You Win!' : 'You Lose!'}</div>
                        <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                    </div>
                `;
                
                document.body.appendChild(gameOverModal);
            }

            async randomPlacement() {
                if (!this.gameState || !this.gameState.players) return;
                
                const player = this.playerNumber;
                
                try {
                    // Clear current ships
                    const clearUpdates = {};
                    for (let row = 0; row < 10; row++) {
                        for (let col = 0; col < 10; col++) {
                            clearUpdates[`rooms/${this.roomCode}/players/${player}/board/${row}/${col}`] = 0;
                        }
                    }
                    
                    // Reset ship states
                    Object.keys(this.gameState.players[player].ships).forEach(shipType => {
                        clearUpdates[`rooms/${this.roomCode}/players/${player}/ships/${shipType}/placed`] = false;
                    });

                    await this.database.ref().update(clearUpdates);

                    // Place ships randomly
                    const shipSizes = [5, 4, 3, 3, 2];
                    const shipTypes = ['carrier', 'battleship', 'cruiser', 'submarine', 'destroyer'];
                    
                    for (let i = 0; i < shipSizes.length; i++) {
                        let placed = false;
                        let attempts = 0;
                        
                        while (!placed && attempts < 100) {
                            const row = Math.floor(Math.random() * 10);
                            const col = Math.floor(Math.random() * 10);
                            const orientation = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                            
                            if (this.canPlaceShip(row, col, shipSizes[i], orientation, player)) {
                                await this.placeShip(row, col, shipSizes[i], orientation, player);
                                await this.database.ref(`rooms/${this.roomCode}/players/${player}/ships/${shipTypes[i]}/placed`).set(true);
                                placed = true;
                            }
                            attempts++;
                        }
                    }

                    // Update UI
                    document.querySelectorAll('.ship-item').forEach(item => {
                        item.classList.add('placed');
                        item.classList.remove('selected');
                    });
                    
                    this.selectedShip = null;
                    this.checkReadyState();
                } catch (error) {
                    console.error('Error with random placement:', error);
                }
            }

            updateStatus() {
                // Auto-fix: if both players ready but no battle phase set, force it
                if (this.gamePhase === 'setup' && this.gameState && this.gameState.players && 
                    this.gameState.players[1] && this.gameState.players[2] &&
                    this.gameState.players[1].shipsReady && this.gameState.players[2].shipsReady &&
                    (!this.gameState.gameState || !this.gameState.gameState.battlePhase)) {
                    
                    setTimeout(async () => {
                        if (this.playerNumber === 1) {
                            await this.database.ref(`rooms/${this.roomCode}/gameState`).update({
                                battlePhase: true,
                                gameStarted: true,
                                currentPlayer: 1
                            });
                        }
                        this.gamePhase = 'game';
                        this.updateGamePhaseClasses();
                        this.setupPhase.style.display = 'none';
                        this.renderBoards();
                        this.updatePlayerSections();
                        this.updateStatus();
                    }, 1000);
                }
                
                if (this.gamePhase === 'setup') {
                    this.gameStatus.textContent = `Place your ships on your board`;
                } else if (this.gamePhase === 'game' && this.gameState && this.gameState.gameState) {
                    const currentPlayer = this.gameState.gameState.currentPlayer;
                    if (currentPlayer === this.playerNumber) {
                        this.gameStatus.textContent = `Your turn - Click on opponent's board to attack!`;
                    } else {
                        this.gameStatus.textContent = `Opponent's turn - Wait for their move`;
                    }
                } else if (this.gamePhase === 'connection') {
                    this.gameStatus.textContent = `Connecting to multiplayer...`;
                }
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Check if Firebase is available
            if (typeof firebase === 'undefined') {
                alert('Firebase failed to load. Please check your internet connection and refresh the page.');
                return;
            }
            
            try {
                new BattleshipGame();
            } catch (error) {
                console.error('Failed to initialize game:', error);
                alert('Failed to initialize game. Please refresh the page and try again.');
            }
        });
    </script>
</body>
</html> 